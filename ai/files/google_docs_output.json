[
  {
    "title": "Llama-RAG",
    "text": "from langchain_ollama import ChatOllama from langchain.prompts import PromptTemplate from langchain_core.output_parsers import StrOutputParser from .vectorDatabase import VectorDB import time from datetime import datetime  class LlamaRAG: llm_instance = ChatOllama(model=\"llama3:latest\", temperature=0.6, num_ctx= 2048)  prompt = PromptTemplate( template=\"\"\"<|begin_of_text|><|start_header_id|>system<|end_header_id|> Cutting Knowledge Date: December 2023 Today Date: {today_date}  Sei un assistente utile e preciso. Usa i documenti forniti per rispondere con accuratezza. Se i documenti non contengono la risposta, basati sulla tua conoscenza. Rispondi solo in italiano.<|eot_id|>  <|start_header_id|>user<|end_header_id|> Domanda: {question} Documenti: {documents}<|eot_id|>  <|start_header_id|>assistant<|end_header_id|> \"\"\", input_variables=[\"question\", \"documents\", \"today_date\"], ) rag_chain_instance = prompt | llm_instance | StrOutputParser() retriever = VectorDB()  def __init__(self): LlamaRAG.retriever.addAllDocuments()  def generateResponse(self, query): start_time = time.time() documents = self.retriever.searchDocument(query) mid_time = time.time() print(f\"Tempo per la ricerca: {mid_time - start_time:.2f} secondi\")  prompt_input = { \"question\": query, \"documents\": documents if documents else \"Nessun documento rilevante trovato.\", \"today_date\": datetime.today().strftime('%Y-%m-%d') }  response = LlamaRAG.rag_chain_instance.invoke(prompt_input)  end_time = time.time() print(f\"Tempo totale: {end_time - start_time:.2f} secondi\") return response "
  },
  {
    "title": "PROGETTO : Relazione finale",
    "text": "PROGETTO il progetto mira  a sviluppare un’applicazione che simula un chatbot. Le risposte sono gestite da un modello LLM open source che tramite tecnica RAG ha accesso ai documenti dell’utente in modo da poter rispondere a domande riguardanti documenti dell'utente specifico oltre che a rispondere usando la sua conoscenza. I documenti in questione sono presi con le api di google quindi il progetto è stato registrato su google cloud abilitando le api necessarie e salvando gli id del client privato e pubblico in variabili d’ambiente  SERVIZI  Di seguito vengono illustrati i servizi utilizzati per lo sviluppo dell’applicazione.  WEB APP Questo servizio è stato implementato con react ed è suddiviso nei seguenti componenti: login.js : si occupa di gestire il login con le credenziali di google. Una volta fatto il login con successo si ottiene un token identificativo che lo scambia con un token di accesso alle api di google. dashboard.js : una volta eseguito il login si viene reindirizzati su questa pagina dove l’utente potrà interagire con IA facendo domande o registrando audio. L'audio viene  gestito con react-speech-recognition"
  },
  {
    "title": "RAG:vector database, model LLM, embedding",
    "text": "Questa relazione descrive e argomenta le tecnologie scelte per lo sviluppo del progetto, basato su l'assistenza di un ia personale. Le tecnologie scelte sono : model LLM  Il modello LLM che ho scelto è Llama 3 (META),4,7 GB e 8.0 B di parametri. Affiancato da Ollama che offre una semplice API per interagire con i modelli di linguaggio e utile per eseguire i modelli in locale senza necessità di una connessione a un server esterno.  vector database  Per la gestione del database vettoriale ho deciso di adoperare Facebook AI Similarity Search (FAISS) che  è una libreria per la ricerca efficiente di similarità e il clustering di vettori densi. Faiss sfrutta la potenza computazionale delle GPU per accelerare significativamente le operazioni di ricerca di similarità. Quindi grazie a un focus sulla velocità e sull'utilizzo della memoria eccelle nel fornire ricerche di similarità rapide anche all'interno di vasti set di dati. Inoltre la capacità della libreria di gestire grandi volumi di dati ad alta dimensionalità mantenendo l'efficienza della query lo rende una scelta affidabile. Per quanto riguarda il nostro scenario particolare, lo reputo una scelta più che adatta. Un'altra scelta è Langchain, framework open source per la creazione di applicazioni basate su modelli linguistici di grandi dimensioni (LLM). Langchain mette a disposizione strumenti che permettono di personalizzare l'accuratezza e la pertinenza delle informazioni generate dai modelli.  embedding  Per il trasformatore utilizzo all-miniLM-l6-v2, versione meno pesante del all-mpnet-base-v2 ma reputo sufficiente per la nostra casistica.   OBBIETTIVO  Arrivare a una versione base in cui il modello ha un certo grado di correttezza nella risposta, senza tralasciare l’efficienza e le performance dell’applicazione stessa. Testando successivamente  i risultati finali in rapporto alle tecnologie utilizzate.  "
  },
  {
    "title": "Progetto",
    "text": "Il progetto ha come obiettivo lo sviluppo di un’applicazione avanzata di assistenza vocale, integrata con funzionalità di gestione di immagini e documenti. L’applicazione è suddivisa in due componenti principali: il frontend e il backend, ognuno dei quali gioca un ruolo importante per garantire una user experience fluida e interattiva. Frontend: Interfaccia Utente Il frontend permette all’utente di interagire in modo semplice e intuitivo con l’applicazione attraverso una web app responsiva. La web app è progettata per essere facilmente accessibile da qualsiasi dispositivo, come computer, tablet o smartphone. Gli utenti possono caricare vari tipi di file, tra cui: • File audio (per la gestione di comandi vocali e interazioni basate su voce) • Documenti di testo (PDF, Word, Excel) per estrarre e analizzare contenuti. • Immagini che possono essere analizzate per estrarre informazioni tramite tecniche di computer vision. Ogni volta che l’utente carica un file, il sistema avvia il processo di elaborazione dei dati, che include la trascrizione del file audio in testo, l’analisi del contenuto delle immagini o l’estrazione di testo dai documenti. Le risposte vengono poi visualizzate direttamente nell’interfaccia, fornendo un feedback immediato. Inoltre, l’interfaccia consente di personalizzare le impostazioni della voce del bot, consentendo all’utente di scegliere tra diverse opzioni di voce, tono e intonazione. L’obiettivo è rendere l’interazione più naturale e personalizzata, migliorando l’esperienza utente. Tutti gli input provenienti dall’utente, come comandi vocali, documenti o immagini, vengono inviati al backend per un’ulteriore elaborazione e per ottenere una risposta basata sull’intelligenza artificiale. Backend: Elaborazione Dati e Intelligenza Artificiale Il backend è il cuore dell’applicazione e si occupa dell’elaborazione di tutti i dati che arrivano dal frontend. È basato su Llama, un potente modello linguistico open-source di grandi dimensioni, che consente di generare risposte complesse e contestualizzate in modo estremamente preciso. L’interazione tra il frontend e il backend avviene tramite richieste API, che inviano i dati da processare al server, dove avviene l’elaborazione. Una delle principali funzionalità del backend riguarda la gestione dei file audio. I file audio caricati vengono processati tramite una tecnologia avanzata di Speech-to-Text (STT). Questo processo consente di trascrivere il contenuto del file audio in testo, che viene poi elaborato dal modello Llama per generare una risposta adeguata. L’intelligenza artificiale, utilizzando il modello linguistico, analizza il testo, interpreta le richieste dell’utente e produce una risposta pertinente. In aggiunta alla gestione dell’audio, il sistema è in grado di gestire immagini e documenti. Quando l’utente carica un’immagine, il sistema fa uso della Google Vision API, un servizio di computer vision basato su machine learning, che consente di analizzare l’immagine e estrarre informazioni utili. Per esempio, può riconoscere oggetti, etichette, testi o anche sentimenti presenti nell’immagine. Inoltre, l’applicazione è in grado di gestire documenti tramite la tecnologia OCR (Optical Character Recognition). Questo permette di estrarre testo da immagini contenenti scritte, come fotografie di documenti, o da documenti in formati come PDF o immagini scanrate, migliorando ulteriormente la capacità dell’applicazione di interagire con contenuti visivi. Memoria Conversazionale e Gestione del Contesto Un’altra caratteristica fondamentale del backend è la gestione della memoria conversazionale. L’applicazione utilizza un database vettoriale per memorizzare le conversazioni precedenti, il che consente di migliorare l’interazione con l’utente nel tempo. Il sistema è in grado di recuperare il contesto delle conversazioni passate e utilizzarlo per migliorare la qualità delle risposte future. Ad esempio, se l’utente ha chiesto in precedenza informazioni su un argomento specifico, l’assistente vocale sarà in grado di riprendere la conversazione dove era stata interrotta, senza richiedere nuovamente le stesse informazioni. Questo tipo di memoria rende l’esperienza molto più fluida e naturale, adattandosi progressivamente alle preferenze e alle necessità dell’utente. Supporto Multiutente Il sistema è progettato per gestire conversazioni con più utenti contemporaneamente, un aspetto particolarmente utile in ambienti dove più persone potrebbero utilizzare l’applicazione nello stesso momento, come in contesti aziendali o familiari. Ogni utente può avere un proprio profilo personalizzato, che include preferenze vocali, storico delle conversazioni e altre impostazioni personalizzabili. Questo permette di adattare l’esperienza in modo unico per ciascun utente, creando un ambiente altamente personalizzato per ogni interazione. Il supporto multiutente consente anche una gestione efficace delle sessioni simultanee, garantendo che ogni richiesta venga trattata separatamente e che le risposte siano accurate e contestualizzate per ogni singolo utente.  "
  },
  {
    "title": "Documento senza titolo",
    "text": "abbiamo provato, con un altro ragazzo, a suonare all’ufficio di Viroli, ma non ha risposto nessuno. Abbiamo chiesto in segreteria, ma ci hanno detto che probabilmente non c’è oggi. Ci hanno consigliato di scrivere a garante@unibo.it e a Viroli, esponendo il problema. Il garante dicono sia utile perchè darebbe manforte alle tesi degli studenti, quindi ce l’hanno consigliato per darci una mano. Ci hanno comunque detto che è davvero difficile che si riesca a fare qualcosa entro domani, contando che sia Viroli che il garante dovrebbero fare un’indagine per vedere se la tesi è fondata (da quanto ci ha detto la portineria)."
  },
  {
    "title": "Risposte a domande passate Tecnologie Web (2022)",
    "text": "Domande e risposte esami passati Tecnologie Web (Domande fino a 2022) Luca Casadei  Cosa ha introdotto HTML5 Una maggiore flessibilità, infatti, si discosta dalla sintassi rigida di XHTML e non la forza. Introduce nuovi elementi (tag) che consentono di dare una struttura semantica alle parti di documento, oltre che a elementi di controllo, menù e navigazione ed altri elementi per l’accessibilità. Codifica dei caratteri Per poter rappresentare un carattere, è necessario definirlo attraverso una codifica in bit, ogni combinazione di bit rappresenta un carattere diverso in base alla codifica scelta, UTF-8 utilizza una quantità di bit variabile, la codifica ASCII invece usa 7 bit fissi ma non rappresenta tutti i caratteri accentati dell’alfabeto latino, rappresentati invece dalla codifica ISO Latin1 Mobile first - Responsive Il design Mobile First è un’evoluzione del design responsive, il secondo infatti, si basa sul principio della graceful degradation, mentre il primo su quello del progressive enhancement, migliorando così l’esperienza degli utilizzatori di dispositivi mobili. Graceful degradation - Progressive enhancement Il principio di graceful degradation prevede come punto di partenza il design di pagine adatte a dispositivi più grandi, e man mano ridurre elementi dallo schermo quando questo diventa più piccolo, diminuendo così le funzionalità. Il principio di progressive enhancement prevede che si parta col design dell’applicazione per dispositivi mobili che contiene già i vincoli principali (le feature), e aggiungere delle funzionalità secondarie man mano che si aumenta la dimensione. UX E’ un concetto sviluppatosi da quello di usabilità, quindi lo estende, descrive la reazione dell’utente di fronte all’interazione con lo strumento, in base anche all’aspetto estetico e simbolico (brand), oltre che pragmatico. Usabilità, con riferimento alla norma ISO 9241 La norma ISO 9241 definisce il concetto di usabilità come: Il grado in cui un prodotto è utilizzabile da un certo gruppo di utenti per raggiungere obiettivi in maniera efficace ed efficiente. E’ un concetto incluso in quello di UX. Personas, scenarios, focus group Personas : Impersonificazione del target dell’applicazione, redatta in maniera specifica, per ogni progetto sono molteplici Scenarios : Azioni dettagliate descritte in sequenza per ogni “personas”, riguardante uno specifico obiettivo, motivazione, contesto e distrazione. Focus group : Discussioni sul prodotto fatte assieme al target, permettono di capire ciò che l’utente dice di fare (non quello che fa effettivamente, a questo risponde il test con utenza). Cos’è accessibilità Capacità di un sistema informatico di erogare informazioni fruibili al maggior numero di utenza senza discriminazione, anche da parte di coloro che usano dispositivi di supporto alla disabilità (Screenreader, ecc…), l’usabilità invece non è indirizzata specificatamente alle persone con disabilità, ma è un concetto più generale. WCAG 2.0 e differenza da legge Stanca (04/2004) La WCAG 2.0 è basata su 4 principi, per ognuno 12 linee guida non verificabili, per ciascuna linea guida “ n ” criteri di successo verificabili. Ciascuno di es si suddivide in diversi livelli di conformità (A, AA, AAA). La legge stanca si articola in 6 documenti tecnici, di cui il primo si articola in 12 requisiti, ciascuno di essi verificato attraverso dei punti di controllo. La numerosità dei requisiti è analoga a quella delle linee guida WCAG. CSS 3.0 Rispetto alle versioni precedenti, la specifica di CSS3 è divisa in moduli, più facilmente mantenibili e consultabili, inoltre, inserisce elementi per la gestione del design responsive (o mobile first) come le media query. Introduce anche nuove modalità di uso dei bordi, sfondi, ombre, gradienti etc… Descrivere brevemente il concetto di “cascata” nei fogli di stile e definire come si applica e come vengono gestiti eventuali conflitti con fogli di stile inline, fogli di stile interni e fogli di stile esterni. CSS incoraggia molteplici fogli di stile in cascata, lo stile che viene applicato dipende da come vengono ordinate le regole, in particolare, seguendo questo principio: Media Importanza (!important) Origine (Server web, utente, browser) Specificità (xywz dove x = 1 se inline, y = n. di id, w = n. di classi e attributi, z = n. di tag) Ordine delle dichiarazioni (cascata) Descrivere come è possibile scambiare i valori delle variabili tra Javascript e Php. (Necessaria revisione) E’ possibile facendo richieste GET o POST da javascript verso un’interfaccia PHP, che a sua volta ritornerà al richiedente una risposta. Descrivere tutte le tecniche/modalità/crismi, dal punto di vista della sicurezza, in modo che la trasmissione di dati sensibili dal browser al server sia \"sicura\". Utilizzare un protocollo che consenta la crittografia (HTTPS su TLS), utilizzare forti algoritmi di hashing per offuscare le password, possibilmente che consentano la salatura senza troppo spreco di risorse, non effettuare operazioni sensibili lato client, ma esclusivamente lato server per evitare che un utente alteri i risultati di suddette operazioni, proteggersi da attacchi comuni quali cross-site request forgery (CSRF). Illustrare le differenze, i vantaggi e gli svantaggi di fogli di stile esterni, interni e inline. Esterni: Mantengono una separazione tra struttura e presentazione, più facili da mantenere, codice pulito. Interni: Il server non perde tempo a caricare una risorsa esterna per lo stile (irrilevante con le tecnologie moderne), molto brutto nel complesso. Inline: Non bisogna impazzire con gli specificatori, molto brutto, non vi è separazione di alcun tipo tra presentazione e struttura. Design User-Centered Si basa sul definire con precisione il target (gruppo di utenti a cui è destinato l’utilizzo dell’app), vedi personas, scenarios, focus group, è quella roba lì. Quali sono i 3 standard alla base del web Sono un linguaggio di markup basato sugli stessi principi di XML, un protocollo di comunicazione di tipo client server ed un indirizzo universale ed univoco per le risorse, rispettivamente, HTML, HTTP/S, URI (Unified resource Identifier) che si compone dell’URL. Come funziona lo scambio di informazioni tra client e server usando un browser web Lo scambio avviene mediante il protocollo HTTP/S basato su TCP per la connessione. Il client manda una richiesta al server attraverso il suo browser immettendo l’URI della risorsa che si vuole raggiungere, comunica allo stesso tempo i cookie salvati dal server nella sessione precedente, una volta ricevuta la richiesta, il web server la elabora e restituisce una risposta al client, generalmente mediante formato HTML. Differenze tra i solution stack LAMP e MEAN LAMP: Linux - Apache - MySQL - PHP/Perl/Python è un solution stack basato su sistemi operativi GNU/Linux, quindi dipendente dal sistema operativo (esiste una versione multipiattaforma, XAMPP) MEAN: MongoDB (NoSQL) - Express.js - Angular.js - Node.js è un solution stack che specifica anche i componenti per lo sviluppo client, oltre che server, e si basa sul principio di usare javascript come unico linguaggio.  Codifica dei colori La codifica dei colori in CSS3 può avvenire in diverse modalità, quali: Codifica RGB mediante una combinazione dei 3 colori primari, esprimibile anche mediante il formato esadecimale #RRGGBB, vengono combinati in sintesi addittiva (sommando i valori fino al bianco) Mediante il nome inglese dei colori Altri spazi additivi più semplici da gestire (HSL, HSV…)"
  },
  {
    "title": "Documento senza titolo",
    "text": "1) Quali dei seguenti requisiti incoraggiano l’adozione di una interfaccia code-based? (1/31 punti) a. elevata mole di lavoro da svolgere b. apprendibilità c. riutilizzo della conoscenza pregressa d. soddisfazione dell’utente e. memorabilità  2) Quale tra i seguenti meccanismi del paradigma a oggetti è alla base della progettazione di associazioni in UML? (1/31 punti) a. delegazione b. ereditarietà c. polimorfismo d. incapsulamento  3) Qual è la differenza tra errori bloccanti e non bloccanti rilevati durante il collaudo di un sistema software? (1/31 punti) a. i primi pregiudicano lo svolgimento del collaudo, i secondi no b. i primi comportano l’arresto del software, i secondi no c. i primi sono relativi all’operatività, i secondi agli aspetti prestazionali d. non esiste questa differenziazione  4) “Una coppia di sposi si reca presso il negozio e compila la lista di nozze insieme a una commessa”. Questa specifica è rilevante con riferimento a quali tipi di aspetti? (2/31 punti) a. statici b. dinamici c. funzionali  5) A quali tipi di elementi UML si applica la relazione di contenimento, rappresentata da un segno + circondato da un cerchio? (1/31 punti) a. alle classi b. ai casi d’uso c. ai package d. agli stati e. ai componenti f. ai nodi  6) Quali tra i seguenti diagrammi UML possono avere sia forma di descrittore sia forma di istanza? (2/31 punti) a. deployment b. classi c. stati d. casi d’uso  7) Quale tra le seguenti qualità è posseduta da un processo di produzione del software in grado di valutare correttamente e rispettare i tempi di consegna? (1/31 punti) a. robustezza b. correttezza c. efficienza d. produttività e. tempestività 8) Quali delle seguenti classi dovrebbero essere presenti nel metamodello di un diagramma delle classi? (2/31 punti) a. Messaggio b. Dipendenza c. Evento d. Azione e. Aggregazione f. Classe g. Flusso di oggetti h. Associazione"
  },
  {
    "title": "Documento senza titolo",
    "text": "1) Con riferimento al diagramma degli stati UML mostrato in figura, quali delle seguenti affermazioni sono vere? (3/31 punti) a. quando l’oggetto si trova nello stato R, può trovarsi indifferentemente negli stati S, X e W b. quando l’oggetto entra nello stato R, entra negli stati T e V c. quando accade l’evento c, l’oggetto entra nello stato W d. l’oggetto non può trovarsi contemporaneamente negli stati T e V e. l’oggetto non può trovarsi contemporaneamente negli stati T e X f. l’oggetto non può raggiungere lo stato X se prima non è accaduto l’evento a  2) Quali di questi diagrammi UML vengono normalmente utilizzati a supporto del collaudo del software, con particolare riferimento al “testing in the large”? (1/31 punti) a. Sequenza b. Attività c. Classi d. Casi d'uso  3) Un software viene sottoposto a refactoring per renderlo più manutenibile. Di che tipo di manutenzione si tratta? (1/31 punti) a. Correttiva b. Evolutiva c. Perfettiva d. Adattiva  4) Quale di questi modelli di produzione del software è specificamente pensato per ridurre la durata del ciclo di sviluppo per software facilmente modularizzabili? (2/31 punti) a. modello a cascata b. modello RAD c. modello evolutivo a spirale d. model-driven development e. modello extreme programming 5) Quali sono le principali caratteristiche del modello di produzione extreme programming? (2/31 punti) a. incoraggia la progettazione di funzionalità aggiuntive b. in presenza di problemi di design, incoraggia il ricorso a spike solution c. è pensato per ridurre il rischio di progetto d. richiede comunicazione continua tra sviluppatori e utenti e. è iterativo e incrementale 6) Un gruppo di tabelle viene acceduto da un’applicazione A ma è gestito da un’applicazione B. In quale modo può essere classificato nel metodo function points applicato ad A? (2/31 punti) a. ILF (file interno logico) b. EIF (file esterno di interfaccia) c. EI (input esterno) d. EO (output esterno) e. EQ (query esterna) 7) E’ dato il diagramma delle classi in figura, che rappresenta un portale per la gestione delle missioni effettuate dai volontari della vigilanza antincendio."
  },
  {
    "title": "Documento senza titolo",
    "text": "header {  border-bottom : 1px  solid  #35a9df ; }  body > header > div.header-container {  display : flex ;  align-items : center ;  justify-content : space-between ; }  body > header > div > img.logo {  width : 50px ; }  body > header > div > img.listIcon {  width : 5% ; }  body > header > div > img.ShoppingCart {  width : 5% ; } "
  },
  {
    "title": "Documento senza titolo",
    "text": "def metodo_bisezione(fname, a, b, tolx,tolf): \"\"\" Implementa il metodo di bisezione per il calcolo degli zeri di un'equazione non lineare.  Parametri: f: La funzione da cui si vuole calcolare lo zero. a: L'estremo sinistro dell'intervallo di ricerca. b: L'estremo destro dell'intervallo di ricerca. tol: La tolleranza di errore.  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista di valori intermedi. \"\"\" fa=fname(a) fb=fname(b) if sign(fa)*sign(fb)>=0:# print(\"Non è possibile applicare il metodo di bisezione \\n\") return None, None,None  it = 0 v_xk = []  maxit = math.ceil(math.log2((b - a) / tolx))-1  while abs(b - a) > tolx:# xk = a+(b-a)/2# v_xk.append(xk) it += 1 fxk=fname(xk) if fxk==0: return xk, it, v_xk  if sign(fa)*sign(fxk)>0:  #continua su [xk,b] a = xk# fa=fxk# elif sign(fxk)*sign(fb)>0:   #continua su [a,xk] b = xk# fb=fxk#  return xk, it, v_xk  def falsi(fname, a, b, maxit, tolx,tolf): \"\"\" Implementa il metodo di falsa posizione per il calcolo degli zeri di un'equazione non lineare.  Parametri: f: La funzione da cui si vuole calcolare lo zero. a: L'estremo sinistro dell'intervallo di ricerca. b: L'estremo destro dell'intervallo di ricerca. tol: La tolleranza di errore.  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista di valori intermedi. \"\"\" fa=fname(a) fb=fname(b) if sign(fa)*sign(fb)>=0:# print(\"Non è possibile applicare il metodo di falsa posizione \\n\") return None, None,None  it = 0 v_xk = []  fxk=10  while it < maxit and abs(b - a) > tolx and abs(fxk) > tolf:# xk = a-fa*(b-a)/(fb-fa)# v_xk.append(xk) it += 1 fxk=fname(xk) if fxk==0: return xk, it, v_xk  if sign(fa)*sign(fxk)>0:  #continua su [xk,b] a = xk# fa=fxk# elif sign(fxk)*sign(fb)>0:   #continua su [a,xk] b = xk# fb=fxk#  return xk, it, v_xk  def corde(fname,m,x0,tolx,tolf,nmax): \"\"\" Implementa il metodo delle corde per il calcolo degli zeri di un'equazione non lineare.  Parametri: fname: La funzione da cui si vuole calcolare lo zero. m: coefficiente angolare della retta che rimane fisso per tutte le iterazioni tolx: La tolleranza di errore tra due iterati successivi tolf: tolleranza sul valore della funzione nmax: numero massimo di iterazione  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista degli iterati intermedi. \"\"\" xk=[] fx0=fname(x0)# d=fx0/m# x1=x0-d# fx1=fname(x1) xk.append(x1) it=1  while it<nmax and  abs(fx1)>=tolf and abs(d)>=tolx*abs(x1) :# x0=x1# fx0=fname(x0)# d=fx0/m# ''' #x1= ascissa del punto di intersezione tra  la retta che passa per il punto (xi,f(xi)) e ha pendenza uguale a m  e l'asse x ''' x1=x0-d  # fx1=fname(x1) it=it+1  xk.append(x1)  if it==nmax: print('raggiunto massimo numero di iterazioni \\n')  return x1,it,xk  def newton(fname,fpname,x0,tolx,tolf,nmax): \"\"\" Implementa il metodo di Newton per il calcolo degli zeri di un'equazione non lineare.  Parametri: fname: La funzione di cui si vuole calcolare lo zero. fpname: La derivata prima della funzione di  cui si vuole calcolare lo zero. x0: iterato iniziale tolx: La tolleranza di errore tra due iterati successivi tolf: tolleranza sul valore della funzione nmax: numero massimo di iterazione  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista degli iterati intermedi. \"\"\" xk=[] fx0=fname(x0) if abs(fpname(x0))<=np.spacing(1):# #Se la derivata prima e' pià piccola della precisione di macchina stop print(\" derivata prima nulla in x0\") return None, None,None  d=fx0/fpname(x0)# x1=x0-d#  fx1=fname(x1) xk.append(x1) it=1  while it<nmax and  abs(fx1)>=tolf and abs(d)>=tolx*abs(x1) :# x0=x1# fx0=fname(x0)# if abs(fpname(x0))<=np.spacing(1):# #Se la derivata prima e' pià piccola della precisione di macchina stop print(\" derivata prima nulla in x0\") return None, None,None d=fx0/fpname(x0)# ''' #x1= ascissa del punto di intersezione tra  la retta che passa per il punto (xi,f(xi)) ed è tangente alla funzione f(x) nel punto (xi.f(xi))  e l'asse x ''' x1=x0-d  # fx1=fname(x1) it=it+1  xk.append(x1)  if it==nmax: print('raggiunto massimo numero di iterazioni \\n')   return x1,it,xk  def secanti(fname,xm1,x0,tolx,tolf,nmax): \"\"\" Implementa il metodo delle secanti per il calcolo degli zeri di un'equazione non lineare.  Parametri: fname: La funzione di cui si vuole calcolare lo zero. xm1, x0: primi due iterati tolx: La tolleranza di errore tra due iterati successivi tolf: tolleranza sul valore della funzione nmax: numero massimo di iterazione  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista degli iterati intermedi. \"\"\" xk=[] fxm1=fname(xm1)# fx0=fname(x0)# d=fx0*(x0-xm1)/(fx0-fxm1)# x1=x0-d# xk.append(x1) fx1=fname(x1) it=1  while it<nmax and abs(fx1)>=tolf and abs(d)>=tolx*abs(x1): xm1=x0# x0=x1# fxm1=fname(xm1)# fx0=fname(x0) # d=fx0*(x0-xm1)/(fx0-fxm1)# x1=x0-d# fx1=fname(x1) xk.append(x1) it=it+1  if it==nmax: print('Secanti: raggiunto massimo numero di iterazioni \\n')  return x1,it,xk  def newton_mod(fname,fpname,m,x0,tolx,tolf,nmax): \"\"\" Implementa il metodo di Newton modificato da utilizzato per il calcolo degli zeri di un'equazione non lineare nel caso di zeri multipli.  Parametri: fname: La funzione di cui si vuole calcolare lo zero. fpname: La derivata prima della funzione di  cui si vuole calcolare lo zero. m: molteplicità della radice x0: iterato iniziale tolx: La tolleranza di errore tra due iterati successivi tolf: tolleranza sul valore della funzione nmax: numero massimo di iterazione  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista degli iterati intermedi. \"\"\"  xk=[] fx0=fname(x0) if abs(fpname(x0))<=np.spacing(1): #Se la derivata prima e' pià piccola della precisione di macchina stop print(\" derivata prima nulla in x0\") return None, None,None  d=fx0/fpname(x0) x1=x0-m*d  fx1=fname(x1) xk.append(x1) it=1  while it<nmax and  abs(fx1)>=tolf and abs(d)>=tolx*abs(x1) : x0=x1 fx0=fname(x0) if abs(fpname(x0))<=np.spacing(1): #Se la derivata prima e' pià piccola della precisione di macchina stop print(\" derivata prima nulla in x0\") return None, None,None d=fx0/fpname(x0) ''' #x1= ascissa del punto di intersezione tra  la retta che passa per il punto (xi,f(xi)) ed è tangente alla funzione f(x) nel punto (xi.f(xi))  e l'asse x ''' x1=x0-m*d fx1=fname(x1) it=it+1  xk.append(x1)  if it==nmax: print('raggiunto massimo numero di iterazioni \\n')  return x1,it,xk  def stima_ordine(xk,iterazioni): #Vedi dispensa allegata per la spiegazione  k=iterazioni-4 p=np.log(abs(xk[k+2]-xk[k+3])/abs(xk[k+1]-xk[k+2]))/np.log(abs(xk[k+1]-xk[k+2])/abs(xk[k]-xk[k+1]));  ordine=p return ordine   return ordine  def my_newtonSys(fun, jac, x0, tolx, tolf, nmax): \"\"\" Funzione per la risoluzione del sistema F(x)=0 mediante il metodo di Newton.  Parametri ---------- fun : funzione vettoriale contenente ciascuna equazione non lineare del sistema. jac : funzione che calcola la matrice Jacobiana della funzione vettoriale. x0 : array Vettore contenente l'approssimazione iniziale della soluzione. tolx : float Parametro di tolleranza per l'errore assoluto. tolf : float Parametro di tolleranza per l'errore relativo. nmax : int Numero massimo di iterazioni.  Restituisce ------- x : array Vettore soluzione del sistema (o equazione) non lineare. it : int Numero di iterazioni fatte per ottenere l'approssimazione desiderata. Xm : array Vettore contenente la norma dell'errore relativo tra due iterati successivi. \"\"\" matjac = jac(x0) if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None, None,None  s = -np.linalg.solve(matjac, fun(x0)) # Aggiornamento della soluzione it = 1 x1 = x0 + s fx1 = fun(x1)  Xm = [np.linalg.norm(s, 1)/np.linalg.norm(x1,1)]  while it <= nmax and np.linalg.norm(fx1, 1) >= tolf and np.linalg.norm(s, 1) >= tolx * np.linalg.norm(x1, 1): x0 = x1 it += 1 matjac = jac(x0) if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None, None,None  # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Jacobiana e come termine noto la Funzione vettoriale F valutata # in x0 s = -np.linalg.solve(matjac, fun(x0))  # Aggiornamento della soluzione x1 = x0 + s fx1 = fun(x1) Xm.append(np.linalg.norm(s, 1)/np.linalg.norm(x1,1))  return x1, it, Xm  def my_newtonSys_corde(fun, jac, x0, tolx, tolf, nmax): \"\"\" Funzione per la risoluzione del sistema f(x)=0 mediante il metodo di Newton, con variante delle corde, in cui lo Jacobiano non viene calcolato ad ogni iterazione, ma rimane fisso, calcolato nell'iterato iniziale x0.  Parametri ---------- fun : funzione vettoriale contenente ciascuna equazione non lineare del sistema. jac : funzione che calcola la matrice Jacobiana della funzione vettoriale. x0 : array Vettore contenente l'approssimazione iniziale della soluzione. tolx : float Parametro di tolleranza per l'errore tra due soluzioni successive. tolf : float Parametro di tolleranza sul valore della funzione. nmax : int Numero massimo di iterazioni.  Restituisce ------- x : array Vettore soluzione del sistema (o equazione) non lineare. it : int Numero di iterazioni fatte per ottenere l'approssimazione desiderata. Xm : array Vettore contenente la norma dell'errore relativo tra due iterati successivi. \"\"\" matjac = jac(x0)  #Utilizzo per tutte le iterazioni la matrice Jacobiana valutata nell'ierato iniziale, senza mai aggiornarla if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None, None,None s = -np.linalg.solve(matjac, fun(x0)) # Aggiornamento della soluzione it = 1 x1 = x0 + s fx1 = fun(x1)  Xm = [np.linalg.norm(s, 1)/np.linalg.norm(x1,1)]  while it <= nmax and np.linalg.norm(fx1, 1) >= tolf and np.linalg.norm(s, 1) >= tolx * np.linalg.norm(x1, 1): x0 = x1 it += 1  if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None, None,None  # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Jacobiana e come termine noto la Funzione vettoriale F valutata # in x0  s = -np.linalg.solve(matjac, fun(x0))  # Aggiornamento della soluzione x1 = x0 + s fx1 = fun(x1) Xm.append(np.linalg.norm(s, 1)/np.linalg.norm(x1,1))  return x1, it, Xm  def my_newtonSys_sham(fun, jac, x0, tolx, tolf, nmax): \"\"\" Funzione per la risoluzione del sistema f(x)=0 mediante il metodo di Newton, con variante delle shamanski, in cui lo Jacobiano viene aggiornato ogni un tot di iterazioni, deciso dall'utente.  Parametri ---------- fun : funzione vettoriale contenente ciascuna equazione non lineare del sistema. jac : funzione che calcola la matrice Jacobiana della funzione vettoriale. x0 : array Vettore contenente l'approssimazione iniziale della soluzione. tolx : float Parametro di tolleranza per l'errore tra due soluzioni successive. tolf : float Parametro di tolleranza sul valore della funzione. nmax : int Numero massimo di iterazioni.  Restituisce ------- x : array Vettore soluzione del sistema (o equazione) non lineare. it : int Numero di iterazioni fatte per ottenere l'approssimazione desiderata. Xm : array Vettore contenente la norma dell'errore relativo tra due iterati successivi. \"\"\" matjac = jac(x0) if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None,None,None  s = -np.linalg.solve(matjac, fun(x0)) # Aggiornamento della soluzione it = 1 x1 = x0 + s fx1 = fun(x1)  Xm = [np.linalg.norm(s, 1)/np.linalg.norm(x1,1)] update=10  #Numero di iterazioni durante le quali non si aggiorna la valutazione dello Jacobiano nell'iterato attuale while it <= nmax and np.linalg.norm(fx1, 1) >= tolf and np.linalg.norm(s, 1) >= tolx * np.linalg.norm(x1, 1): x0 = x1 it += 1 if it%update==0:   #Valuto la matrice di iterazione nel nuovo iterato ogni \"update\" iterazioni matjac=jac(x0)  if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None,None,None else: # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Jacobiana valutatata nell'iterato aggiornato x0  e come termine noto la Funzione vettoriale F valutata # in x0 s = -np.linalg.solve(matjac, fun(x0)) else: # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Jacobiana non aggiornata e come termine noto la Funzione vettoriale F valutata # in x0 s = -np.linalg.solve(matjac, fun(x0))  # Aggiornamento della soluzione x1 = x0 + s fx1 = fun(x1) Xm.append(np.linalg.norm(s, 1)/np.linalg.norm(x1,1))  return x1, it, Xm  def my_newton_minimo(gradiente, Hess, x0, tolx, tolf, nmax): \"\"\" DA UTILIZZARE NEL CASO IN CUI CALCOLATE DRIVATE PARZIALI PER GRADIENTE ED HESSIANO SENZA UTILIZZO DI SYMPY  Funzione di newton-raphson per calcolare il minimo di una funzione in più variabili  Parametri ---------- fun : Nome della funzione che calcola il gradiente della funzione non lineare. Hess : Nome della funzione che calcola la matrice Hessiana della funzione non lineare. x0 : array Vettore contenente l'approssimazione iniziale della soluzione. tolx : float Parametro di tolleranza per l'errore assoluto. tolf : float Parametro di tolleranza per l'errore relativo. nmax : int Numero massimo di iterazioni.  Restituisce ------- x : array Vettore soluzione del sistema (o equazione) non lineare. it : int Numero di iterazioni fatte per ottenere l'approssimazione desiderata. Xm : array Vettore contenente la norma del passo ad ogni iterazione. \"\"\" matHess = Hess(x0) if np.linalg.det(matHess) == 0: print(\"La matrice Hessiana calcolata nell'iterato precedente non è a rango massimo\") return None, None, None grad_fx0= gradiente(x0) s = -np.linalg.solve(matHess, gradiente(x0)) # Aggiornamento della soluzione it = 1 x1 = x0 + s grad_fx1 = gradiente(x1) Xm = [np.linalg.norm(s, 1)]  while it <= nmax and np.linalg.norm(grad_fx1 , 1) >= tolf and np.linalg.norm(s, 1) >= tolx * np.linalg.norm(x1, 1):  x0 = x1 it += 1 matHess = Hess(x0) grad_fx0=grad_fx1  if np.linalg.det(matHess) == 0: print(\"La matrice Hessiana calcolata nell'iterato precedente non è a rango massimo\") return None, None, None  # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Hessiana e come termine il vettore gradiente calcolato nell'iterato precedente # in x0 s = -np.linalg.solve(matHess, grad_fx0)  # Aggiornamento della soluzione x1 = x0 + s  #Calcolo del gradiente nel nuovo iterato grad_fx1  = gradiente(x1) print(np.linalg.norm(s, 1)) Xm.append(np.linalg.norm(s, 1))  return x1, it, Xm  def my_newton_minimo_MOD(gradiente, Hess, x0, tolx, tolf, nmax): \"\"\" Funzione di newton-raphson per calcolare il minimo di una funzione in più variabili, modificato nel caso in cui si utilizzando sympy per calcolare Gradiente ed Hessiano. Rispetto alla precedente versione cambia esclusivamente il modo di valutare il vettore gradiente e la matrice Hessiana in un punto Parametri ---------- fun : Nome della funzione che calcola il gradiente della funzione non lineare. Hess : Nome della funzione che calcola la matrice Hessiana della funzione non lineare. x0 : array Vettore contenente l'approssimazione iniziale della soluzione. tolx : float Parametro di tolleranza per l'errore assoluto. tolf : float Parametro di tolleranza per l'errore relativo. nmax : int Numero massimo di iterazioni.  Restituisce ------- x : array Vettore soluzione del sistema (o equazione) non lineare. it : int Numero di iterazioni fatte per ottenere l'approssimazione desiderata. Xm : array Vettore contenente la norma del passo ad ogni iterazione. \"\"\" matHess = np.array([[Hess[0, 0](x0[0], x0[1]), Hess[0, 1](x0[0], x0[1])], [Hess[1, 0](x0[0], x0[1]), Hess[1, 1](x0[0], x0[1])]])  gradiente_x0=np.array([gradiente[0](x0[0], x0[1]),gradiente[1](x0[0], x0[1])])  if np.linalg.det(matHess) == 0: print(\"La matrice Hessiana calcolata nell'iterato precedente non è a rango massimo\") return None, None, None  s = -np.linalg.solve(matHess, gradiente_x0) print(s) # Aggiornamento della soluzione it = 1 x1 = x0 + s grad_fx1=np.array([gradiente[0](x1[0],x1[1]),gradiente[1](x1[0],x1[1])]) Xm = [np.linalg.norm(s, 1)]  while it <= nmax and np.linalg.norm(grad_fx1, 1) >= tolf and np.linalg.norm(s, 1) >= tolx * np.linalg.norm(x1, 1):  x0 = x1 it += 1 matHess = np.array([[Hess[0, 0](x0[0], x0[1]), Hess[0, 1](x0[0], x0[1])], [Hess[1, 0](x0[0], x0[1]), Hess[1, 1](x0[0], x0[1])]]) grad_fx0=grad_fx1  if np.linalg.det(matHess) == 0:  print(\"La matrice Hessiana calcolata nell'iterato precedente non è a rango massimo\") return None, None, None  # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Hessiana e come termine il vettore gradiente calcolato nell'iterato precedente # in x0 #NB: in fx1 è memorizzato il gradiente nell'iterato attuale s = -np.linalg.solve(matHess, grad_fx0)  # Aggiornamento della soluzione x1 = x0 + s #Aggiorno il gradiente per la prossima iterazione grad_fx1=np.array([gradiente[0](x1[0],x1[1]),gradiente[1](x1[0],x1[1])]) print(np.linalg.norm(s, 1)) Xm.append(np.linalg.norm(s, 1))  return x1, it, Xm  def creaPoisson(n): #costruire una matrice di Poisson d=np.ones((n))*4 e=-np.ones((n-1,)) f=-np.ones((n-3,)) A=np.diag(d)+np.diag(e,-1)+np.diag(e,1)+np.diag(f,-3)+np.diag(f,3) return A  def jacobi(A,b,x0,toll,it_max): errore=1000 d=np.diag(A) n=A.shape[0] invM=np.diag(1/d) E=np.tril(A,-1) F=np.triu(A,1) N=-(E+F) T=np.dot(invM,N) autovalori=np.linalg.eigvals(T) raggiospettrale=np.max(np.abs(autovalori)) print(\"raggio spettrale jacobi\", raggiospettrale) it=0  er_vet=[] while it<=it_max and errore>=toll: x=(b+np.dot(N,x0))/d.reshape(n,1) errore=np.linalg.norm(x-x0)/np.linalg.norm(x) er_vet.append(errore) x0=x.copy() it=it+1 return x,it,er_vet  def gauss_seidel(A,b,x0,toll,it_max): errore=1000 d=np.diag(A) D=np.diag(d)# E=np.tril(A,-1)# F=np.triu(A,1)# M=D+E# N=-F# T=np.dot(np.linalg.inv(M),N)# autovalori=np.linalg.eigvals(T) raggiospettrale=np.max(np.abs(autovalori))# print(\"raggio spettrale Gauss-Seidel \",raggiospettrale) it=0 er_vet=[] while it<=it_max and errore>=toll:# temp=b-F@x0# x,flag=Lsolve(M,temp)#  #Calcolare la soluzione al passo k equivale a calcolare la soluzione del sistema triangolare con matrice M=D+E # e termine noto b-F@x0 errore=np.linalg.norm(x-x0)/np.linalg.norm(x) er_vet.append(errore) x0=x.copy() it=it+1 return x,it,er_vet  def gauss_seidel_sor(A,b,x0,toll,it_max,omega): errore=1000 d=np.diag(A)# D=np.diag(d)# Dinv=np.diag(1/d)# E=np.tril(A,-1)# F=np.triu(A,1)# Momega=D+omega*E Nomega=(1-omega)*D-omega*F T=np.dot(np.linalg.inv(Momega),Nomega)# autovalori=np.linalg.eigvals(T) raggiospettrale=np.max(np.abs(autovalori)) print(\"raggio spettrale Gauss-Seidel SOR \", raggiospettrale)  M=D+E N=-F it=0 xold=x0.copy() xnew=x0.copy() er_vet=[] while it<=it_max and errore>=toll:# temp=b-np.dot(F,xold)# xtilde,flag=Lsolve(M,temp)# xnew=(1-omega)*xold+omega*xtilde# errore=np.linalg.norm(xnew-xold)/np.linalg.norm(xnew) er_vet.append(errore) xold=xnew.copy() it=it+1 return xnew,it,er_vet  def steepestdescent(A,b,x0,itmax,tol): n,m=A.shape if n!=m: print(\"Matrice non quadrata\") return [],[]  # inizializzare le variabili necessarie x = x0  r = A@x-b p = -r it = 0 nb=np.linalg.norm(b) errore=np.linalg.norm(r)/nb vec_sol=[] vec_sol.append(x) vet_r=[] vet_r.append(errore)  # utilizzare il metodo del gradiente per trovare la soluzione while errore>= tol and it< itmax:# it=it+1 Ap=A@p#  alpha = -(r.T@p)/(p.T@Ap)#  x = x + alpha*p#  #aggiornamento della soluzione nella direzione opposta a quella del gradiente: alpha mi dice dove fermarmi #nella direzione del gradiente affinche F(xk+t p ) <F(xk)   vec_sol.append(x) r=r+alpha*Ap errore=np.linalg.norm(r)/nb vet_r.append(errore) p = -r ##Direzione opposta alla direzione del gradiente  return x,vet_r,vec_sol,it  def steepestdescent_CL(A,b,x0,itmax,X,Y,Z,f,tol): #solo per matrici di dimensioni 2 n,m=A.shape if n!=m: print(\"Matrice non quadrata\") return [],[]  # inizializzare le variabili necessarie x = x0  plt.contour(X, Y, Z, levels=f(x,A,b).flatten()) plt.plot(x[0],x[1],'r-o') r = A@x-b p = -r it = 0 nb=np.linalg.norm(b) errore=np.linalg.norm(r)/nb vec_sol=[] vec_sol.append(x) vet_r=[] vet_r.append(errore)  # utilizzare il metodo del gradiente per trovare la soluzione while errore>= tol and it< itmax: it=it+1 Ap=A@p  alpha = -(r.T@p)/(p.T@Ap) x = x + alpha*p   plt.contour(X, Y, Z, levels=f(x,A,b).flatten()) plt.plot(x[0],x[1],'ro') vec_sol.append(x) r=r+alpha*Ap errore=np.linalg.norm(r)/nb vet_r.append(errore) p = -r  plt.show() return x,vet_r,vec_sol,it  def conjugate_gradient(A,b,x0,itmax,tol): n,m=A.shape if n!=m: print(\"Matrice non quadrata\") return [],[]  # inizializzare le variabili necessarie x = x0  r = A@x-b p = -r it = 0 nb=np.linalg.norm(b) errore=np.linalg.norm(r)/nb vec_sol=[] vec_sol.append(x0) vet_r=[] vet_r.append(errore) # utilizzare il metodo del gradiente coniugato per calcolare la soluzione while errore >= tol and it< itmax: it=it+1 Ap=A.dot(p) rtr=np.dot(r.T, r) alpha = rtr / np.dot(p.T, Ap) x = x + alpha *p vec_sol.append(x) r=r+alpha*Ap gamma=np.dot(r.T,r)/rtr errore=np.linalg.norm(r)/nb vet_r.append(errore) p = -r+gamma*p  return x,vet_r,vec_sol,it  def conjugate_gradient_CL(A,b,x0,itmax,X,Y,Z,f,tol): n,m=A.shape if n!=m: print(\"Matrice non quadrata\") return [],[]  # inizializzare le variabili necessarie x = x0 plt.contour(X, Y, Z, levels=f(x,A,b).flatten()) plt.plot(x[0],x[1],'ro')  r = A.dot(x)-b p = -r it = 0 nb=np.linalg.norm(b) errore=np.linalg.norm(r)/nb vec_sol=[] vec_sol.append(x0) vet_r=[] vet_r.append(errore) # utilizzare il metodo del gradiente coniugato per trovare la soluzione while errore >= tol and it< itmax: it=it+1 Ap=A@p#  alpha = -(r.T@p)/(p.T@Ap)# x = x + alpha *p# plt.contour(X, Y, Z, levels=f(x,A,b).flatten()) plt.plot(x[0],x[1],'ro') vec_sol.append(x) rtr_old=r.T@r r=r+alpha*Ap gamma=np.dot(r.T,r)/rtr_old errore=np.linalg.norm(r)/nb vet_r.append(errore) p = -r+gamma*p #  return x,vet_r,vec_sol,it  def eqnorm(A,b): #Risolve un sistema sovradeterminato con il metodo delle equazioni normali G=A.T@A condG=np.linalg.cond(G) print(\"Indice di condizionamento di G \",condG) f=A.T@b  L=spLin.cholesky(G,lower=True) U=L.T  z,flag=SolveTriangular.Lsolve(L,f) if flag==0: x,flag=SolveTriangular.Usolve(U,z)  return x  def qrLS(A,b): #Risolve un sistema sovradeterminato con il metodo QR-LS n=A.shape[1]  # numero di colonne di A Q,R=spLin.qr(A) h=Q.T@b # x,flag=SolveTriangular.Usolve(R[0:n,:],h[0:n])# residuo=np.linalg.norm(h[n:])**2 return x,residuo  def SVDLS(A,b): \"\"\" Metodo SVD per la soluzione del sistema sovradeterminato Ax=b DATI INPUT: - la matrice A di dimensione m x n, m>n - il termine noto b di ordine m DATI OUTPUT: - la soluzione del sistema lineare e la norma 2 al quadrato del residuo. \"\"\" #Risolve un sistema sovradeterminato con il metodo SVD-LS m,n=A.shape  #numero di righe e  numero di colonne di A U,s,VT=spLin.svd(A)  #Attenzione : Restituisce U, il numpy-array 1d che contiene la diagonale della matrice Sigma e VT=VTrasposta) #Quindi V=VT.T thresh=np.spacing(1)*m*s[0] ##Calcolo del rango della matrice, numero dei valori singolari maggiori di una soglia k=np.count_nonzero(s>thresh) print(\"rango=\",k) d=U.T@b # d1=d[:k].reshape(k,1)# s1=s[:k].reshape(k,1)# #Risolve il sistema diagonale di dimensione kxk avene come matrice dei coefficienti la matrice Sigma c=d1/s1# x=V[:,:k]@c residuo=np.linalg.norm(d[k:])**2 return x,residuo  def plagr(xnodi,j): \"\"\" Restituisce i coefficienti del k-esimo pol di Lagrange associato ai punti del vettore xnodi \"\"\" xzeri=np.zeros_like(xnodi) n=xnodi.size if j==0: xzeri=xnodi[1:n] else: xzeri=np.append(xnodi[0:j],xnodi[j+1:n])#  num=np.poly(xzeri) # den=np.polyval(num,xnodi[j]) #  p=num/den  return p  def InterpL(x, y, xx): \"\"\" Funzione che determina in un insieme di punti il valore del polinomio interpolante ottenuto dalla formula di Lagrange. DATI INPUT x  vettore con i nodi dell'interpolazione f  vettore con i valori dei nodi xx vettore con i punti in cui si vuole calcolare il polinomio DATI OUTPUT y vettore contenente i valori assunti dal polinomio interpolante \"\"\" n=x.size m=xx.size L=np.zeros((m,n)) for j in range(n): p=plagr(x,j) # L[:,j]=np.polyval(p,xx) #  return L@y  "
  },
  {
    "title": "Documento senza titolo",
    "text": "def metodo_bisezione(fname, a, b, tolx,tolf):  \"\"\"  Implementa il metodo di bisezione per il calcolo degli zeri di un'equazione non lineare.  Parametri: f: La funzione da cui si vuole calcolare lo zero. a: L'estremo sinistro dell'intervallo di ricerca. b: L'estremo destro dell'intervallo di ricerca. tol: La tolleranza di errore.  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista di valori intermedi. \"\"\" fa=fname(a) fb=fname(b) if sign(fa)*sign(fb)>=0:# print(\"Non è possibile applicare il metodo di bisezione \\n\") return None, None,None  it = 0 v_xk = []  maxit = math.ceil(math.log2((b - a) / tolx))-1  while abs(b - a) > tolx:# xk = a+(b-a)/2# v_xk.append(xk) it += 1 fxk=fname(xk) if fxk==0: return xk, it, v_xk  if sign(fa)*sign(fxk)>0:  #continua su [xk,b] a = xk# fa=fxk# elif sign(fxk)*sign(fb)>0:   #continua su [a,xk] b = xk# fb=fxk#  return xk, it, v_xk  def falsi(fname, a, b, maxit, tolx,tolf): \"\"\" Implementa il metodo di falsa posizione per il calcolo degli zeri di un'equazione non lineare.  Parametri: f: La funzione da cui si vuole calcolare lo zero. a: L'estremo sinistro dell'intervallo di ricerca. b: L'estremo destro dell'intervallo di ricerca. tol: La tolleranza di errore.  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista di valori intermedi. \"\"\" fa=fname(a) fb=fname(b) if sign(fa)*sign(fb)>=0:# print(\"Non è possibile applicare il metodo di falsa posizione \\n\") return None, None,None  it = 0 v_xk = []  fxk=10  while it < maxit and abs(b - a) > tolx and abs(fxk) > tolf:# xk = a-fa*(b-a)/(fb-fa)# v_xk.append(xk) it += 1 fxk=fname(xk) if fxk==0: return xk, it, v_xk  if sign(fa)*sign(fxk)>0:  #continua su [xk,b] a = xk# fa=fxk# elif sign(fxk)*sign(fb)>0:   #continua su [a,xk] b = xk# fb=fxk#  return xk, it, v_xk  def corde(fname,m,x0,tolx,tolf,nmax): \"\"\" Implementa il metodo delle corde per il calcolo degli zeri di un'equazione non lineare.  Parametri: fname: La funzione da cui si vuole calcolare lo zero. m: coefficiente angolare della retta che rimane fisso per tutte le iterazioni tolx: La tolleranza di errore tra due iterati successivi tolf: tolleranza sul valore della funzione nmax: numero massimo di iterazione  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista degli iterati intermedi. \"\"\" xk=[] fx0=fname(x0)# d=fx0/m# x1=x0-d# fx1=fname(x1) xk.append(x1) it=1  while it<nmax and  abs(fx1)>=tolf and abs(d)>=tolx*abs(x1) :# x0=x1# fx0=fname(x0)# d=fx0/m# ''' #x1= ascissa del punto di intersezione tra  la retta che passa per il punto (xi,f(xi)) e ha pendenza uguale a m  e l'asse x ''' x1=x0-d  # fx1=fname(x1) it=it+1  xk.append(x1)  if it==nmax: print('raggiunto massimo numero di iterazioni \\n')  return x1,it,xk  def newton(fname,fpname,x0,tolx,tolf,nmax): \"\"\" Implementa il metodo di Newton per il calcolo degli zeri di un'equazione non lineare.  Parametri: fname: La funzione di cui si vuole calcolare lo zero. fpname: La derivata prima della funzione di  cui si vuole calcolare lo zero. x0: iterato iniziale tolx: La tolleranza di errore tra due iterati successivi tolf: tolleranza sul valore della funzione nmax: numero massimo di iterazione  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista degli iterati intermedi. \"\"\" xk=[] fx0=fname(x0) if abs(fpname(x0))<=np.spacing(1):# #Se la derivata prima e' pià piccola della precisione di macchina stop print(\" derivata prima nulla in x0\") return None, None,None  d=fx0/fpname(x0)# x1=x0-d#  fx1=fname(x1) xk.append(x1) it=1  while it<nmax and  abs(fx1)>=tolf and abs(d)>=tolx*abs(x1) :# x0=x1# fx0=fname(x0)# if abs(fpname(x0))<=np.spacing(1):# #Se la derivata prima e' pià piccola della precisione di macchina stop print(\" derivata prima nulla in x0\") return None, None,None d=fx0/fpname(x0)# ''' #x1= ascissa del punto di intersezione tra  la retta che passa per il punto (xi,f(xi)) ed è tangente alla funzione f(x) nel punto (xi.f(xi))  e l'asse x ''' x1=x0-d  # fx1=fname(x1) it=it+1  xk.append(x1)  if it==nmax: print('raggiunto massimo numero di iterazioni \\n')   return x1,it,xk  def secanti(fname,xm1,x0,tolx,tolf,nmax): \"\"\" Implementa il metodo delle secanti per il calcolo degli zeri di un'equazione non lineare.  Parametri: fname: La funzione di cui si vuole calcolare lo zero. xm1, x0: primi due iterati tolx: La tolleranza di errore tra due iterati successivi tolf: tolleranza sul valore della funzione nmax: numero massimo di iterazione  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista degli iterati intermedi. \"\"\" xk=[] fxm1=fname(xm1)# fx0=fname(x0)# d=fx0*(x0-xm1)/(fx0-fxm1)# x1=x0-d# xk.append(x1) fx1=fname(x1) it=1  while it<nmax and abs(fx1)>=tolf and abs(d)>=tolx*abs(x1): xm1=x0# x0=x1# fxm1=fname(xm1)# fx0=fname(x0) # d=fx0*(x0-xm1)/(fx0-fxm1)# x1=x0-d# fx1=fname(x1) xk.append(x1) it=it+1  if it==nmax: print('Secanti: raggiunto massimo numero di iterazioni \\n')  return x1,it,xk  def newton_mod(fname,fpname,m,x0,tolx,tolf,nmax): \"\"\" Implementa il metodo di Newton modificato da utilizzato per il calcolo degli zeri di un'equazione non lineare nel caso di zeri multipli.  Parametri: fname: La funzione di cui si vuole calcolare lo zero. fpname: La derivata prima della funzione di  cui si vuole calcolare lo zero. m: molteplicità della radice x0: iterato iniziale tolx: La tolleranza di errore tra due iterati successivi tolf: tolleranza sul valore della funzione nmax: numero massimo di iterazione  Restituisce: Lo zero approssimato della funzione, il numero di iterazioni e la lista degli iterati intermedi. \"\"\"  xk=[] fx0=fname(x0) if abs(fpname(x0))<=np.spacing(1): #Se la derivata prima e' pià piccola della precisione di macchina stop print(\" derivata prima nulla in x0\") return None, None,None  d=fx0/fpname(x0) x1=x0-m*d  fx1=fname(x1) xk.append(x1) it=1  while it<nmax and  abs(fx1)>=tolf and abs(d)>=tolx*abs(x1) : x0=x1 fx0=fname(x0) if abs(fpname(x0))<=np.spacing(1): #Se la derivata prima e' pià piccola della precisione di macchina stop print(\" derivata prima nulla in x0\") return None, None,None d=fx0/fpname(x0) ''' #x1= ascissa del punto di intersezione tra  la retta che passa per il punto (xi,f(xi)) ed è tangente alla funzione f(x) nel punto (xi.f(xi))  e l'asse x ''' x1=x0-m*d fx1=fname(x1) it=it+1  xk.append(x1)  if it==nmax: print('raggiunto massimo numero di iterazioni \\n')  return x1,it,xk  def stima_ordine(xk,iterazioni): #Vedi dispensa allegata per la spiegazione  k=iterazioni-4 p=np.log(abs(xk[k+2]-xk[k+3])/abs(xk[k+1]-xk[k+2]))/np.log(abs(xk[k+1]-xk[k+2])/abs(xk[k]-xk[k+1]));  ordine=p return ordine   return ordine  def my_newtonSys(fun, jac, x0, tolx, tolf, nmax): \"\"\" Funzione per la risoluzione del sistema F(x)=0 mediante il metodo di Newton.  Parametri ---------- fun : funzione vettoriale contenente ciascuna equazione non lineare del sistema. jac : funzione che calcola la matrice Jacobiana della funzione vettoriale. x0 : array Vettore contenente l'approssimazione iniziale della soluzione. tolx : float Parametro di tolleranza per l'errore assoluto. tolf : float Parametro di tolleranza per l'errore relativo. nmax : int Numero massimo di iterazioni.  Restituisce ------- x : array Vettore soluzione del sistema (o equazione) non lineare. it : int Numero di iterazioni fatte per ottenere l'approssimazione desiderata. Xm : array Vettore contenente la norma dell'errore relativo tra due iterati successivi. \"\"\" matjac = jac(x0) if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None, None,None  s = -np.linalg.solve(matjac, fun(x0)) # Aggiornamento della soluzione it = 1 x1 = x0 + s fx1 = fun(x1)  Xm = [np.linalg.norm(s, 1)/np.linalg.norm(x1,1)]  while it <= nmax and np.linalg.norm(fx1, 1) >= tolf and np.linalg.norm(s, 1) >= tolx * np.linalg.norm(x1, 1): x0 = x1 it += 1 matjac = jac(x0) if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None, None,None  # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Jacobiana e come termine noto la Funzione vettoriale F valutata # in x0 s = -np.linalg.solve(matjac, fun(x0))  # Aggiornamento della soluzione x1 = x0 + s fx1 = fun(x1) Xm.append(np.linalg.norm(s, 1)/np.linalg.norm(x1,1))  return x1, it, Xm  def my_newtonSys_corde(fun, jac, x0, tolx, tolf, nmax): \"\"\" Funzione per la risoluzione del sistema f(x)=0 mediante il metodo di Newton, con variante delle corde, in cui lo Jacobiano non viene calcolato ad ogni iterazione, ma rimane fisso, calcolato nell'iterato iniziale x0.  Parametri ---------- fun : funzione vettoriale contenente ciascuna equazione non lineare del sistema. jac : funzione che calcola la matrice Jacobiana della funzione vettoriale. x0 : array Vettore contenente l'approssimazione iniziale della soluzione. tolx : float Parametro di tolleranza per l'errore tra due soluzioni successive. tolf : float Parametro di tolleranza sul valore della funzione. nmax : int Numero massimo di iterazioni.  Restituisce ------- x : array Vettore soluzione del sistema (o equazione) non lineare. it : int Numero di iterazioni fatte per ottenere l'approssimazione desiderata. Xm : array Vettore contenente la norma dell'errore relativo tra due iterati successivi. \"\"\" matjac = jac(x0)  #Utilizzo per tutte le iterazioni la matrice Jacobiana valutata nell'ierato iniziale, senza mai aggiornarla if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None, None,None s = -np.linalg.solve(matjac, fun(x0)) # Aggiornamento della soluzione it = 1 x1 = x0 + s fx1 = fun(x1)  Xm = [np.linalg.norm(s, 1)/np.linalg.norm(x1,1)]  while it <= nmax and np.linalg.norm(fx1, 1) >= tolf and np.linalg.norm(s, 1) >= tolx * np.linalg.norm(x1, 1): x0 = x1 it += 1  if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None, None,None  # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Jacobiana e come termine noto la Funzione vettoriale F valutata # in x0  s = -np.linalg.solve(matjac, fun(x0))  # Aggiornamento della soluzione x1 = x0 + s fx1 = fun(x1) Xm.append(np.linalg.norm(s, 1)/np.linalg.norm(x1,1))  return x1, it, Xm  def my_newtonSys_sham(fun, jac, x0, tolx, tolf, nmax): \"\"\" Funzione per la risoluzione del sistema f(x)=0 mediante il metodo di Newton, con variante delle shamanski, in cui lo Jacobiano viene aggiornato ogni un tot di iterazioni, deciso dall'utente.  Parametri ---------- fun : funzione vettoriale contenente ciascuna equazione non lineare del sistema. jac : funzione che calcola la matrice Jacobiana della funzione vettoriale. x0 : array Vettore contenente l'approssimazione iniziale della soluzione. tolx : float Parametro di tolleranza per l'errore tra due soluzioni successive. tolf : float Parametro di tolleranza sul valore della funzione. nmax : int Numero massimo di iterazioni.  Restituisce ------- x : array Vettore soluzione del sistema (o equazione) non lineare. it : int Numero di iterazioni fatte per ottenere l'approssimazione desiderata. Xm : array Vettore contenente la norma dell'errore relativo tra due iterati successivi. \"\"\" matjac = jac(x0) if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None,None,None  s = -np.linalg.solve(matjac, fun(x0)) # Aggiornamento della soluzione it = 1 x1 = x0 + s fx1 = fun(x1)  Xm = [np.linalg.norm(s, 1)/np.linalg.norm(x1,1)] update=10  #Numero di iterazioni durante le quali non si aggiorna la valutazione dello Jacobiano nell'iterato attuale while it <= nmax and np.linalg.norm(fx1, 1) >= tolf and np.linalg.norm(s, 1) >= tolx * np.linalg.norm(x1, 1): x0 = x1 it += 1 if it%update==0:   #Valuto la matrice di iterazione nel nuovo iterato ogni \"update\" iterazioni matjac=jac(x0)  if np.linalg.det(matjac) == 0: print(\"La matrice dello Jacobiano calcolata nell'iterato precedente non è a rango massimo\") return None,None,None else: # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Jacobiana valutatata nell'iterato aggiornato x0  e come termine noto la Funzione vettoriale F valutata # in x0 s = -np.linalg.solve(matjac, fun(x0)) else: # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Jacobiana non aggiornata e come termine noto la Funzione vettoriale F valutata # in x0 s = -np.linalg.solve(matjac, fun(x0))  # Aggiornamento della soluzione x1 = x0 + s fx1 = fun(x1) Xm.append(np.linalg.norm(s, 1)/np.linalg.norm(x1,1))  return x1, it, Xm  def my_newton_minimo(gradiente, Hess, x0, tolx, tolf, nmax): \"\"\" DA UTILIZZARE NEL CASO IN CUI CALCOLATE DRIVATE PARZIALI PER GRADIENTE ED HESSIANO SENZA UTILIZZO DI SYMPY  Funzione di newton-raphson per calcolare il minimo di una funzione in più variabili  Parametri ---------- fun : Nome della funzione che calcola il gradiente della funzione non lineare. Hess : Nome della funzione che calcola la matrice Hessiana della funzione non lineare. x0 : array Vettore contenente l'approssimazione iniziale della soluzione. tolx : float Parametro di tolleranza per l'errore assoluto. tolf : float Parametro di tolleranza per l'errore relativo. nmax : int Numero massimo di iterazioni.  Restituisce ------- x : array Vettore soluzione del sistema (o equazione) non lineare. it : int Numero di iterazioni fatte per ottenere l'approssimazione desiderata. Xm : array Vettore contenente la norma del passo ad ogni iterazione. \"\"\" matHess = Hess(x0) if np.linalg.det(matHess) == 0: print(\"La matrice Hessiana calcolata nell'iterato precedente non è a rango massimo\") return None, None, None grad_fx0= gradiente(x0) s = -np.linalg.solve(matHess, gradiente(x0)) # Aggiornamento della soluzione it = 1 x1 = x0 + s grad_fx1 = gradiente(x1) Xm = [np.linalg.norm(s, 1)]  while it <= nmax and np.linalg.norm(grad_fx1 , 1) >= tolf and np.linalg.norm(s, 1) >= tolx * np.linalg.norm(x1, 1):  x0 = x1 it += 1 matHess = Hess(x0) grad_fx0=grad_fx1  if np.linalg.det(matHess) == 0: print(\"La matrice Hessiana calcolata nell'iterato precedente non è a rango massimo\") return None, None, None  # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Hessiana e come termine il vettore gradiente calcolato nell'iterato precedente # in x0 s = -np.linalg.solve(matHess, grad_fx0)  # Aggiornamento della soluzione x1 = x0 + s  #Calcolo del gradiente nel nuovo iterato grad_fx1  = gradiente(x1) print(np.linalg.norm(s, 1)) Xm.append(np.linalg.norm(s, 1))  return x1, it, Xm  def my_newton_minimo_MOD(gradiente, Hess, x0, tolx, tolf, nmax): \"\"\" Funzione di newton-raphson per calcolare il minimo di una funzione in più variabili, modificato nel caso in cui si utilizzando sympy per calcolare Gradiente ed Hessiano. Rispetto alla precedente versione cambia esclusivamente il modo di valutare il vettore gradiente e la matrice Hessiana in un punto Parametri ---------- fun : Nome della funzione che calcola il gradiente della funzione non lineare. Hess : Nome della funzione che calcola la matrice Hessiana della funzione non lineare. x0 : array Vettore contenente l'approssimazione iniziale della soluzione. tolx : float Parametro di tolleranza per l'errore assoluto. tolf : float Parametro di tolleranza per l'errore relativo. nmax : int Numero massimo di iterazioni.  Restituisce ------- x : array Vettore soluzione del sistema (o equazione) non lineare. it : int Numero di iterazioni fatte per ottenere l'approssimazione desiderata. Xm : array Vettore contenente la norma del passo ad ogni iterazione. \"\"\" matHess = np.array([[Hess[0, 0](x0[0], x0[1]), Hess[0, 1](x0[0], x0[1])], [Hess[1, 0](x0[0], x0[1]), Hess[1, 1](x0[0], x0[1])]])  gradiente_x0=np.array([gradiente[0](x0[0], x0[1]),gradiente[1](x0[0], x0[1])])  if np.linalg.det(matHess) == 0: print(\"La matrice Hessiana calcolata nell'iterato precedente non è a rango massimo\") return None, None, None  s = -np.linalg.solve(matHess, gradiente_x0) print(s) # Aggiornamento della soluzione it = 1 x1 = x0 + s grad_fx1=np.array([gradiente[0](x1[0],x1[1]),gradiente[1](x1[0],x1[1])]) Xm = [np.linalg.norm(s, 1)]  while it <= nmax and np.linalg.norm(grad_fx1, 1) >= tolf and np.linalg.norm(s, 1) >= tolx * np.linalg.norm(x1, 1):  x0 = x1 it += 1 matHess = np.array([[Hess[0, 0](x0[0], x0[1]), Hess[0, 1](x0[0], x0[1])], [Hess[1, 0](x0[0], x0[1]), Hess[1, 1](x0[0], x0[1])]]) grad_fx0=grad_fx1  if np.linalg.det(matHess) == 0:  print(\"La matrice Hessiana calcolata nell'iterato precedente non è a rango massimo\") return None, None, None  # Risolvo il sistema lineare avente come matrice dei coefficienti la # matrice Hessiana e come termine il vettore gradiente calcolato nell'iterato precedente # in x0 #NB: in fx1 è memorizzato il gradiente nell'iterato attuale s = -np.linalg.solve(matHess, grad_fx0)  # Aggiornamento della soluzione x1 = x0 + s #Aggiorno il gradiente per la prossima iterazione grad_fx1=np.array([gradiente[0](x1[0],x1[1]),gradiente[1](x1[0],x1[1])]) print(np.linalg.norm(s, 1)) Xm.append(np.linalg.norm(s, 1))  return x1, it, Xm  def creaPoisson(n): #costruire una matrice di Poisson d=np.ones((n))*4 e=-np.ones((n-1,)) f=-np.ones((n-3,)) A=np.diag(d)+np.diag(e,-1)+np.diag(e,1)+np.diag(f,-3)+np.diag(f,3) return A  def jacobi(A,b,x0,toll,it_max): errore=1000 d=np.diag(A) n=A.shape[0] invM=np.diag(1/d) E=np.tril(A,-1) F=np.triu(A,1) N=-(E+F) T=np.dot(invM,N) autovalori=np.linalg.eigvals(T) raggiospettrale=np.max(np.abs(autovalori)) print(\"raggio spettrale jacobi\", raggiospettrale) it=0  er_vet=[] while it<=it_max and errore>=toll: x=(b+np.dot(N,x0))/d.reshape(n,1) errore=np.linalg.norm(x-x0)/np.linalg.norm(x) er_vet.append(errore) x0=x.copy() it=it+1 return x,it,er_vet  def gauss_seidel(A,b,x0,toll,it_max): errore=1000 d=np.diag(A) D=np.diag(d)# E=np.tril(A,-1)# F=np.triu(A,1)# M=D+E# N=-F# T=np.dot(np.linalg.inv(M),N)# autovalori=np.linalg.eigvals(T) raggiospettrale=np.max(np.abs(autovalori))# print(\"raggio spettrale Gauss-Seidel \",raggiospettrale) it=0 er_vet=[] while it<=it_max and errore>=toll:# temp=b-F@x0# x,flag=Lsolve(M,temp)#  #Calcolare la soluzione al passo k equivale a calcolare la soluzione del sistema triangolare con matrice M=D+E # e termine noto b-F@x0 errore=np.linalg.norm(x-x0)/np.linalg.norm(x) er_vet.append(errore) x0=x.copy() it=it+1 return x,it,er_vet  def gauss_seidel_sor(A,b,x0,toll,it_max,omega): errore=1000 d=np.diag(A)# D=np.diag(d)# Dinv=np.diag(1/d)# E=np.tril(A,-1)# F=np.triu(A,1)# Momega=D+omega*E Nomega=(1-omega)*D-omega*F T=np.dot(np.linalg.inv(Momega),Nomega)# autovalori=np.linalg.eigvals(T) raggiospettrale=np.max(np.abs(autovalori)) print(\"raggio spettrale Gauss-Seidel SOR \", raggiospettrale)  M=D+E N=-F it=0 xold=x0.copy() xnew=x0.copy() er_vet=[] while it<=it_max and errore>=toll:# temp=b-np.dot(F,xold)# xtilde,flag=Lsolve(M,temp)# xnew=(1-omega)*xold+omega*xtilde# errore=np.linalg.norm(xnew-xold)/np.linalg.norm(xnew) er_vet.append(errore) xold=xnew.copy() it=it+1 return xnew,it,er_vet  def steepestdescent(A,b,x0,itmax,tol): n,m=A.shape if n!=m: print(\"Matrice non quadrata\") return [],[]  # inizializzare le variabili necessarie x = x0  r = A@x-b p = -r it = 0 nb=np.linalg.norm(b) errore=np.linalg.norm(r)/nb vec_sol=[] vec_sol.append(x) vet_r=[] vet_r.append(errore)  # utilizzare il metodo del gradiente per trovare la soluzione while errore>= tol and it< itmax:# it=it+1 Ap=A@p#  alpha = -(r.T@p)/(p.T@Ap)#  x = x + alpha*p#  #aggiornamento della soluzione nella direzione opposta a quella del gradiente: alpha mi dice dove fermarmi #nella direzione del gradiente affinche F(xk+t p ) <F(xk)   vec_sol.append(x) r=r+alpha*Ap errore=np.linalg.norm(r)/nb vet_r.append(errore) p = -r ##Direzione opposta alla direzione del gradiente  return x,vet_r,vec_sol,it  def steepestdescent_CL(A,b,x0,itmax,X,Y,Z,f,tol): #solo per matrici di dimensioni 2 n,m=A.shape if n!=m: print(\"Matrice non quadrata\") return [],[]  # inizializzare le variabili necessarie x = x0  plt.contour(X, Y, Z, levels=f(x,A,b).flatten()) plt.plot(x[0],x[1],'r-o') r = A@x-b p = -r it = 0 nb=np.linalg.norm(b) errore=np.linalg.norm(r)/nb vec_sol=[] vec_sol.append(x) vet_r=[] vet_r.append(errore)  # utilizzare il metodo del gradiente per trovare la soluzione while errore>= tol and it< itmax: it=it+1 Ap=A@p  alpha = -(r.T@p)/(p.T@Ap) x = x + alpha*p   plt.contour(X, Y, Z, levels=f(x,A,b).flatten()) plt.plot(x[0],x[1],'ro') vec_sol.append(x) r=r+alpha*Ap errore=np.linalg.norm(r)/nb vet_r.append(errore) p = -r  plt.show() return x,vet_r,vec_sol,it  def conjugate_gradient(A,b,x0,itmax,tol): n,m=A.shape if n!=m: print(\"Matrice non quadrata\") return [],[]  # inizializzare le variabili necessarie x = x0  r = A@x-b p = -r it = 0 nb=np.linalg.norm(b) errore=np.linalg.norm(r)/nb vec_sol=[] vec_sol.append(x0) vet_r=[] vet_r.append(errore) # utilizzare il metodo del gradiente coniugato per calcolare la soluzione while errore >= tol and it< itmax: it=it+1 Ap=A.dot(p) rtr=np.dot(r.T, r) alpha = rtr / np.dot(p.T, Ap) x = x + alpha *p vec_sol.append(x) r=r+alpha*Ap gamma=np.dot(r.T,r)/rtr errore=np.linalg.norm(r)/nb vet_r.append(errore) p = -r+gamma*p  return x,vet_r,vec_sol,it  def conjugate_gradient_CL(A,b,x0,itmax,X,Y,Z,f,tol): n,m=A.shape if n!=m: print(\"Matrice non quadrata\") return [],[]  # inizializzare le variabili necessarie x = x0 plt.contour(X, Y, Z, levels=f(x,A,b).flatten()) plt.plot(x[0],x[1],'ro')  r = A.dot(x)-b p = -r it = 0 nb=np.linalg.norm(b) errore=np.linalg.norm(r)/nb vec_sol=[] vec_sol.append(x0) vet_r=[] vet_r.append(errore) # utilizzare il metodo del gradiente coniugato per trovare la soluzione while errore >= tol and it< itmax: it=it+1 Ap=A@p#  alpha = -(r.T@p)/(p.T@Ap)# x = x + alpha *p# plt.contour(X, Y, Z, levels=f(x,A,b).flatten()) plt.plot(x[0],x[1],'ro') vec_sol.append(x) rtr_old=r.T@r r=r+alpha*Ap gamma=np.dot(r.T,r)/rtr_old errore=np.linalg.norm(r)/nb vet_r.append(errore) p = -r+gamma*p #  return x,vet_r,vec_sol,it  def eqnorm(A,b): #Risolve un sistema sovradeterminato con il metodo delle equazioni normali G=A.T@A condG=np.linalg.cond(G) print(\"Indice di condizionamento di G \",condG) f=A.T@b  L=spLin.cholesky(G,lower=True) U=L.T  z,flag=SolveTriangular.Lsolve(L,f) if flag==0: x,flag=SolveTriangular.Usolve(U,z)  return x  def qrLS(A,b): #Risolve un sistema sovradeterminato con il metodo QR-LS n=A.shape[1]  # numero di colonne di A Q,R=spLin.qr(A) h=Q.T@b # x,flag=SolveTriangular.Usolve(R[0:n,:],h[0:n])# residuo=np.linalg.norm(h[n:])**2 return x,residuo  def SVDLS(A,b): \"\"\" Metodo SVD per la soluzione del sistema sovradeterminato Ax=b DATI INPUT: - la matrice A di dimensione m x n, m>n - il termine noto b di ordine m DATI OUTPUT: - la soluzione del sistema lineare e la norma 2 al quadrato del residuo. \"\"\" #Risolve un sistema sovradeterminato con il metodo SVD-LS m,n=A.shape  #numero di righe e  numero di colonne di A U,s,VT=spLin.svd(A)  #Attenzione : Restituisce U, il numpy-array 1d che contiene la diagonale della matrice Sigma e VT=VTrasposta) #Quindi V=VT.T thresh=np.spacing(1)*m*s[0] ##Calcolo del rango della matrice, numero dei valori singolari maggiori di una soglia k=np.count_nonzero(s>thresh) print(\"rango=\",k) d=U.T@b # d1=d[:k].reshape(k,1)# s1=s[:k].reshape(k,1)# #Risolve il sistema diagonale di dimensione kxk avene come matrice dei coefficienti la matrice Sigma c=d1/s1# x=V[:,:k]@c residuo=np.linalg.norm(d[k:])**2 return x,residuo  def plagr(xnodi,j): \"\"\" Restituisce i coefficienti del k-esimo pol di Lagrange associato ai punti del vettore xnodi \"\"\" xzeri=np.zeros_like(xnodi) n=xnodi.size if j==0: xzeri=xnodi[1:n] else: xzeri=np.append(xnodi[0:j],xnodi[j+1:n])#  num=np.poly(xzeri) # den=np.polyval(num,xnodi[j]) #  p=num/den  return p  def InterpL(x, y, xx): \"\"\" Funzione che determina in un insieme di punti il valore del polinomio interpolante ottenuto dalla formula di Lagrange. DATI INPUT x  vettore con i nodi dell'interpolazione f  vettore con i valori dei nodi xx vettore con i punti in cui si vuole calcolare il polinomio DATI OUTPUT y vettore contenente i valori assunti dal polinomio interpolante \"\"\" n=x.size m=xx.size L=np.zeros((m,n)) for j in range(n): p=plagr(x,j) # L[:,j]=np.polyval(p,xx) #  return L@y  "
  },
  {
    "title": "Documento senza titolo",
    "text": ""
  },
  {
    "title": "Documento senza titolo",
    "text": "Buongiorno, le scrivo per chiederle dei chiarimenti sul progetto di Basi di Dati, stiamo calcolando le operazioni, ma non sappiamo come scrivere quelle fatte con delle gerarchie di mezzo. In questo momento stiamo provando a fare le operazioni tipo bonifico, pagamento ecc.. Pensavo in base all'operazione da calcolare, sostituire l`entità padre con la relativa figlia determinata dal tipo di operazione.Inoltre riguardo l`operazione visualizzare gli uffici postali,essendo gia salvati sl database,basta leggere l`entità?perchè nello schema e/r riguardo gli uffici postali ci si arriva tramite prenotazione o recesione,quindi è sorto il dubbio nel caso se vada aggiunta una associazioen tra account e ufficio postale per gestire le operazione ti tipo specifico o generali.    Le chiedo se può darci qualche indicazione su come procedere, le lascio in allegato lo schema E-R, il file Excel con le relative tabelle dei volumi e accessi insieme alle operazioni. Grazie, Alex Frisoni "
  },
  {
    "title": "Documento senza titolo",
    "text": ""
  },
  {
    "title": "Software di gestione per poste italiane",
    "text": "Software di gestione per poste italiane  Il progetto mira a sviluppare un sistema di supporto per le Poste Italiane, agendo come intermediario tra gli utenti finali e i servizi offerti dalle Poste. Gli utenti possono registrarsi al sistema e accedere tramite le proprie credenziali. Il sistema consente la gestione dei conti correnti degli utenti (nome, cognome, ecc.) e l'esecuzione di varie transazioni con le relative commissioni. Gli utenti possono creare uno o più conti correnti e carte, consentendo prelievi, ricariche tra i propri conti, bonifici, depositi e visualizzazione delle spese effettuate in un determinato periodo con relativa media dei soldi spesi.  Le funzionalità offerte dalla piattaforma: registrazione dei nuovi utenti con credenziali. creare nuovi conti correnti. effettuare transazioni. statistiche relative ai movimenti sul conto. gestione dei dati personali degli utenti(profilo utente). visualizzazione dei conti correnti associati all'utente e relativi movimenti.  infine l’amministratore della piattaforma potrà: Possibilità di visualizzare e gestire tutti i conti e le transazioni degli utenti. Monitoraggio delle attività degli utenti e dei flussi di denaro. Gestione delle autorizzazioni e dei ruoli degli utenti. Possibilità di bloccare determinate funzionalità relative a uno specifico utente."
  },
  {
    "title": "NA/EU Island Rewards",
    "text": "NA/EU Island Rewards  I went to every island and did each quest timed to save you time? Any questions or errors contact me at Melo#0001 on Discord\u000b or ask me on my twitch stream .   Please check Papunika , LAOINFO , Maxroll and LostArk Codex for completion, Mokoko, Island Hearts, and specific details on islands. This is only for quest rewards and mainly upgrade materials on said islands. This is not a full Island Guide. Times are based on a  21.9 knots boat, story mount, 0 swiftness support class, and a few select teleports. No previous knowledge required. This also assumes you’re reading this doc or a resource.   Names are currently based on NA/EU names. So you can use the in-game search function.\u000b\u000bDisclaimer: Some values might be different.\u000b\u000bPrefer spanish? Mira aqu í (Credits: Samurai#6443)   Change Log:  v1.0: Doc created\u000bV1.1: Name changed to NA/EU names.\u000bV1.2: All NA/EU Islands listed with position on map.\u000bV1.3: Removed all Islands not in the Beta.\u000bV1.4: Fixed ilvl and avg times to be more realistic.\u000bV1.5: All Islands in Beta listed with materials.\u000bV1.6: Remove colors cause contrast. Use something like Dark Reader to save your eyes.\u000bV1.7: Islands are now categorized based on rewards.\u000bV1.8: Added headers for ease of access.\u000bV2.0: Maxroll info added. Doc is perma maintenance sadge \u000bV2.1: T2 Islands added. Values may vary from NA/EU.\u000bV2.2: Finale revision, no more changes will happen unless I decide so randomly.\u000bV:2.3: 2.2 was a lie. Spanish version added and few detailed updated.  How to read quadrants: 1 2 3 4 5 horizontal starting from the north,\u000b then 6 7 8 9 10 horizontal repeated. Reminder: T2 is at the bottom. T1  Upgrade Materials Engravings Only Engravings + Pirate Coins Pirate Coins Only Etc Islands      T2 Material Islands (Note: Values might be different)  "
  },
  {
    "title": "OrdiniGrandezza",
    "text": "Ordini di Grandezza e analisi asintotica Algoritmi e Strutture Dati Luciano Margara Unibo 2022 B f : N ! N e g : N ! N B Esempi: n log( n ); n 2 +3 n +2; n !; d p n + 2e B Analizziamo il loro comportamento asintotico B Obiettivo: confrontare f e g O grande     O grande, , O grande f ( n ) = O ( g ( n )) se e solo se esistono due costanti n 0 > 0 e c > 0 tali per cui 8 n  n 0 : f ( n ) c  g ( n )  f ( n ) = ( g ( n )) se e solo se esistono due costanti n 0 > 0 e c > 0 tali per cui 8 n  n 0 : f ( n ) c  g ( n )  f ( n ) =  ( g ( n )) se e solo se f ( n ) = O ( g ( n )) e f ( n ) = ( g ( n )) o piccolo, ! piccolo o piccolo f ( n ) = o ( g ( n )) se e solo se f ( n ) = O ( g ( n )) ma f ( n ) 6=  ( g ( n )) ! piccolo f ( n ) = !( g ( n )) se e solo se f ( n ) = ( g ( n )) ma f ( n ) 6=  ( g ( n )) Transitività e riflessività Transitività f ( n ) =  ( g ( n )) e g ( n ) =  ( h ( n )) =) f ( n ) =  ( h ( n )) f ( n ) = O ( g ( n )) e g ( n ) = O ( h ( n )) =) f ( n ) = O ( h ( n )) f ( n ) = ( g ( n )) e g ( n ) = ( h ( n )) =) f ( n ) = ( h ( n )) f ( n ) = o ( g ( n )) e g ( n ) = o ( h ( n )) =) f ( n ) = o ( h ( n )) f ( n ) = !( g ( n )) e g ( n ) = !( h ( n )) =) f ( n ) = !( h ( n )) Riflessività f ( n ) =  ( f ( n )) f ( n ) = O ( f ( n )) f ( n ) = ( f ( n )) Simmetria e simmetria trasposta Simmetria f ( n ) =  ( g ( n )) se e solo se g ( n ) =  ( f ( n )) Simmetria trasposta f ( n ) = O ( g ( n )) se e solo se g ( n ) = ( f ( n )) f ( n ) = o ( g ( n )) se e solo se g ( n ) = !( f ( n )) Ordini di grandezza f ( n ) =  ( g ( n )) f ( n ) = g ( n ) f ( n ) = O ( g ( n )) f ( n ) g ( n ) f ( n ) = ( g ( n )) f ( n ) g ( n ) f ( n ) = o ( g ( n )) f ( n ) < g ( n ) f ( n ) = !( g ( n )) f ( n ) > g ( n ) Relazione d’ordine parziale B Esistono f e g non confrontabili B Esempio: f ( n ) = n e g ( n ) = n 1+ sen ( n ) Limiti e ordini di grandezza limite del rapporto = costante diversa da zero Se lim n >1 f ( n ) g ( n ) = c 6= 0 allora f ( n ) =  ( g ( n )) limite del rapporto = zero Se lim n >1 f ( n ) g ( n ) = 0 allora f ( n ) = o ( g ( n )) limite del rapporto = infinito Se lim n >1 f ( n ) g ( n ) = 1 allora f ( n ) = !( g ( n )) Logaritmi e ordini di grandezza log( f ( n )) = o (log( g ( n ))) =) f ( n ) = o ( g ( n )) log( f ( n )) = !(log( g ( n ))) =) f ( n ) = !( g ( n )) log( f ( n )) =  (log( g ( n ))) =6) f ( n ) =  ( g ( n )) Tassonomia Per ogni M > 0 costante grande a piacere, per ogni   > 0 costante piccolo a piacere, per ogni a > 1 costante: log( n ) M = o ( n  ) n M = o ( a  n ) a Mn = o ( n !) Mn ! = o ( n  n ) Esercizio  Esercizio "
  }
]